Итак, я создал новый пустой проект на Java и сделал сборочный скрипт.
У меня сборка данного проекта происходит при помощи gradle.
Вы можете посмотреть мой учебный проект здесь: https://github.com/risik/tdd-book-java/tree/feature/helloworld.
Начиная вот с этого коммита: d9bd97eaec20427e725f9a4c3ff0c0d36cc27ea3 проект уже готов для сборки и реализации нашего тестового примера.

Теперь я должен начать писать код следуя практики TDD. 
Некоторые апологеты TDD считают, следует начинать разработку класса с написания теста для этого класса.
Но здесь я бы с ними поспорил. 
Моя IDE (IntelliJ IDEA) умеет генерировать тесты при наличии готового класса, поэтому я начну разработку с создания пустого класса: https://github.com/risik/tdd-book-java/commit/0490415ecfea58fb0a75e4b96f90c958dc960834.

А вот теперь я попрошу свою IDE создать мне тест и далее начну работать по схеме test-first. 
Первый тест, который я сделаю, это очень простой тест, при помощи которого я просто создаю новый объект.
Я хочу указывать с кем нужно поздороваться в конструкторе.
Более того, я считаю, что объект выдающий приветствие может выдавать это приветствие, только одному. 
Поэтому, конструктора без параметра у этого класса не будет.
Вот созданный мною первый тест: https://github.com/risik/tdd-book-java/commit/8162299f8fe6a8d924a173ac12479c6dd3d74cc0.
Обратите внимание, что в этой точке проект не компилируется, то есть, тест красный.

Ну сделаю тест зеленым. 
Моя IDE умеет создавать методы класса (в том числе, конструкторы), которые я уже использую, как в созданном тесте, но еще не реализовал.
При помощи одной комбинации клавиш генерирую этот конструктор: https://github.com/risik/tdd-book-java/commit/26dbbd25542d7b0ccbdbac3b99908c90a30ef535 и получаю зеленый тест.
Обратите внимание, что тест, конечно проходит, но фактически, мой класс не делает того, что я от него хотел. 
Работаем дальше.

Создаю тест для метода getWhom - это геттер, при помощи которого я смогу узнать кому этот объект будет выдавать приветствие: https://github.com/risik/tdd-book-java/commit/9496ef269cc034f3843334a0159c9c3de133782b.
Проект опять не компилируется, то есть, тест опять красный. 

Продолжим. 
Реализуем требуемый геттер: https://github.com/risik/tdd-book-java/commit/d8ae54fa2446d8147876093501294400e87f0d4f.
Проект уже компилируется, но тест не проходит.
Для того, чтобы тест проходил, нам теперь придется и конструктор реализовать по-настоящему, а не так, как это я сделал раньше: https://github.com/risik/tdd-book-java/commit/c1b924524f25547f58958ac3f663a5edb19bab98.
Тест опять зеленый.

Маленькое, но важное пояснение.
В этом учебном примере я делаю коммиты в репозитарий очень часто.
Это я делаю для того, чтобы показать читателю последовательность моих шагов. 
Делать коммиты настолько часто в реальном проекте не обязательно.
Хотя я сторонник того, чтобы коммит был "атомарным". 
Что такое атомарный коммит, можно почитать, например, здесь: http://seesparkbox.com/foundry/atomic_commits_with_git.
Крато говоря: до тех пор, пока Вы можете сформулировать, что именно Вы сделали, одним предложением это атомарный коммит.

Ну теперь, реализуем основной метод данного класса: получение приветственного сообщения. 
Вот этот тест: https://github.com/risik/tdd-book-java/commit/1afad7d25045fbd2ca2d3619b57abedaebca242a.
Я ожидаю, что тот, к кому мой говоритель приветствий обращается, возьмет имя в кавычки. 
Тест красный. 

Реализуем требуемый метод: https://github.com/risik/tdd-book-java/commit/507011ce6e0fd13425d43e5fe30a0aac133e2999.
Тест зеленый. 
Я добился прохождения теста очень просто!
Кстати, при реализации метода getWhom я мог сделать также, но в тот раз я сделал все по честному, а здесь, поленился.
Те кому к этому месту надоело заглядывать в diff по ссылке, настоятельно рекомендую сейчас все же пройти по ссылке, приведенной выше.

Итак, у нас проблема: тесты все проходят, но класс делает совсем не то, что нам надо. 
Здесь можно возразить: маловероятно, что такая проблема может возникнуть в реальной жизни, а не в учебном проекте. 
В действительности, модульные тесты обычно разрабатываются тем же человеком, что пишет функциональность. 
Поэтому, было бы очень странно, если бы этот человек, написал реализацию метода, которая настолько не соответствует требованиям.
Но, во вторых, есть случаи, когда тесты и функциональность пишут все же разные люди. 
А во первых, бывают гораздо более сложные случаи, когда разработчик может просто не предусмотреть все возможные варианты входных данных в тестах.

На самом деле, для того, что бы избежать такой некорректной реализации достаточно было бы сделать второй тест с другой строкой whom.
Но мы попытаемся решить этот вопрос для максимально общего случая.
Решение задачи в общем виде требует использовать множество различных строк.
То есть, надо проводить тест не на одной строке "World", как я это сделал, а на разных строках.

Для решения проблемы в общем виде я использовал стороннюю библиотеку junit-quickcheck: https://github.com/pholser/junit-quickcheck, которая построена на базе Theories из JUnit.
Подключаю ее к моему проекту: https://github.com/risik/tdd-book-java/commit/7ca99ae3866cfef0ba926965e34f7f925e7a24ad.
На момент написания статьи версия 0.5, которую я здесь использую, имеет статус alpha, но в ней заявлена поддержка Java 8, которую я использую для этого проекта.

Используя эту библиотеку я реализовал заново тестовой метод для проверки метода greetingString: https://github.com/risik/tdd-book-java/commit/17016c6f4bceee4911623af2d608f07ca750ee11.
Посмотрим что делает этот код. 
Аннотация @Theory при методе указывает, что это параметризованный тестовый метод, построенный на базе therories.
Аннотация @ForAll показывает, что данный параметр будет генерируемый. 
junit-quickcheck из коробки умеет генерировать значения для многих типов данных, в том числе и для строк.

Запускаем тест и теперь он красный, как нам и надо. 
Теперь пофиксим нашу реализацию метода getGreetingString: https://github.com/risik/tdd-book-java/commit/e32647c04c63c71fec89aaf1c45c7708ce681110.
Теперь тест зеленый и реализация, на самом деле, такая, как должна была бы быть.
Рекомендую поставить точку останова и проследить, какие параметры передаются в этот метод.
Я бы таких строк не придумал. :)

Следующим шагом я переписал все тесты с использованием генерации строк: https://github.com/risik/tdd-book-java/commit/154d02f4902773a25644a3494f315b2485892829.
Вообще говоря, это тоже спорный вопрос. 
Если Вам придется отлаживать Ваш код, (например, если на какой-то специфичной входной строке Вы получаете неожиданное поведение).
Отлаживать такую реализацию не очень просто. 
Намного проще реализовать просто тест, который использует строго фиксированную, нужную Вам строку.
Но я, все же заменил все тесты на тесты с генерируемыми параметрами.

Маленький завершающий штришек этого раздела, я добавил к своему проекту контроль покрытия кода.
Использую для этого Jacoco: https://github.com/risik/tdd-book-java/commit/44e31d9ee304989d16bc3bff6bb324c56d0cd205
Прогоняю, смотрю отчет и радуюсь 100% покрытию кода.

Теперь начинаем развивать наш "очень важный" класс HelloSayer.
Мне не очень нравится его реализация.
А конкретно, мне не нравится String.format при каждом вызове метода getGreetingString.
Однако, есть ситуации, когда это будет ОК, а есть ситуации когда меня это не будет устраивать.

Поэтому, я вынесу интерфейс HelloSayer и сделаю несколько его реализаций.
Здесь я опять воспользовался возможностями IntelliJ IDEA по рефакторингу: https://github.com/risik/tdd-book-java/commit/8d77fe55d427566e33403353177b4f76be78c6c7.
Теперь HelloSayer стал интерфейсом, а реализация, которая там была ушла в класс HelloSayerInplace.

А теперь сделаю еще одну реализацию этого интерфейса, которая создает строку приветствия прямо в конструкторе и хранит ее в объекте.
Тест я тоже реализовал, спасибо копировать-и-вставить и поиск-и-замена: https://github.com/risik/tdd-book-java/commit/66641409f1594b370d8b561ba6896615f391231b.

Здесь есть проблема. 
Я хочу еще третью реализацию этого же интерфейса, и соответственно, мне придется сделать третий тестовый класс, опять через тот же механизм копировать-и-вставить и поиск-и-замена.
Это плохо.
Все классы, реализующие этот интерфейс, независимо от того, как именно они реализованы внутри, должны выполнять одно и то же соглашение, которое я уже описал в тесте. 
Я хочу соблюдать принцип DRY (don't repeat youself).
То есть, я хочу применить один и тот же тест ко всем возможным реализациям этого интерфейса.

Здесь мне на помощь опять пришел junit-quickchecker.
Вот модифицированный тест: https://github.com/risik/tdd-book-java/commit/68c287eebe96b5279e581dbf75236f3998a65101.
Я добавил один генерируемый параметр в тестовый метод: тип класса (в виде перечисления).
Перечисления в junit-checker поддерживаются из коробки.
Для этого мне нужно всего лишь добавить аннотацию @ValuesOf.
И, фактически, все что мне нужно было сделать, этот метод для создания экземпляра одного из классов.
Перереализую все тестовые методы с помощью такого параметра: https://github.com/risik/tdd-book-java/commit/ecea8e643e9e2bd379b573c5d762405892b891e9.
Отдельный тестовый класс для нового класса мне теперь больше не нужен, удаляю его: https://github.com/risik/tdd-book-java/commit/b4092eb73177e1efeef6e4cf8c0d888539c393df.

И на закуску, реализую третий вариант HelloSayer: https://github.com/risik/tdd-book-java/commit/50eada1752aacca71b92ea2ae30655fd338a6b60.
Теперь для реализации всех тестов для этого класса мне нужно добавить только 3 строки: https://github.com/risik/tdd-book-java/commit/5a50b25dd6fb20df1b47b21f72b937197ac37cc7.
Проверю, что покрытие кода все еще 100%.

Все отлично!
